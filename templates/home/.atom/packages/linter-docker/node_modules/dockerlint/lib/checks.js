// Generated by CoffeeScript 1.12.4
(function() {
  var args, os, path, utils,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  os = require('os');

  path = require('path');

  utils = require(__dirname + "/utils");

  args = require('subarg')(process.argv.slice(2), {
    alias: {
      d: 'debug',
      f: 'file',
      h: 'help',
      p: 'pedantic'
    }
  });

  if (args.pedantic) {
    exports.pedantic_ret = 'failed';
    exports.pedantic_severity = 'ERROR';
  } else {
    exports.pedantic_ret = 'warning';
    exports.pedantic_severity = 'WARN';
  }

  exports.all = ['arg', 'from_first', 'no_empty_tag', 'no_empty_digest', 'json_array_brackets', 'json_array_even_quotes', 'json_array_format', 'env', 'recommended_exec_form', 'add', 'multiple_entries', 'sudo', 'absolute_workdir', 'onbuild_copyadd', 'onbuild_disallowed', 'label_no_empty_value', 'variable_use', 'no_trailing_spaces', 'unknown_instruction'];

  exports.varPattern = /(?:\$(?:([\w]+)|\{(\w+).*?\}))/g;

  exports.arg = [];

  exports.env = [];

  Array.prototype.filter = function(func) {
    var j, len, ref, results, x;
    ref = this;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      x = ref[j];
      if (func(x)) {
        results.push(x);
      }
    }
    return results;
  };

  exports.getAll = function(instruction, rules) {
    return rules.filter(function(r) {
      return r.instruction === instruction;
    });
  };

  exports.getAllExcept = function(instruction, rules) {
    return rules.filter(function(r) {
      return r.instruction !== instruction;
    });
  };

  exports.getAllVariables = function(rules) {
    this.arg(rules, true);
    this.env(rules, true);
    return utils.merge(exports.arg, exports.env);
  };

  exports.mergeVariables = function(o, rule, empty) {
    var argument, env, j, k, len, len1, p, pair, ref, ref1;
    ref = rule["arguments"];
    for (j = 0, len = ref.length; j < len; j++) {
      argument = ref[j];
      if (argument.split(' ')[0].match(/(\w+)=([^\s]+)/)) {
        ref1 = argument.split(' ');
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          pair = ref1[k];
          p = pair.split(/(\w+)=([^\s]+)/);
          o[p[1]] = p[2];
        }
      } else {
        env = argument.match(/^(\S+)\s(.*)/);
        if (env) {
          env = env.slice(1);
        } else if (argument && empty) {
          o[argument] = '';
          return 'ok';
        } else {
          return 'failed';
        }
        if (env[0] && env[1]) {
          o[env[0]] = env[1];
        } else {
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.variablesDefined = function(vars, s) {
    var m, match;
    while (match = exports.varPattern.exec(s)) {
      m = match[1] || match[2];
      if (!vars[m]) {
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.variablesReplace = function(vars, s) {
    return s.replace(exports.varPattern, function(match, g1, g2, offset, str) {
      var m;
      m = g1 || g2;
      if (vars[m]) {
        return str.replace(match, vars[m]);
      } else {
        return str;
      }
    });
  };

  exports.from_first = function(rules) {
    var first, non_comments;
    non_comments = this.getAllExcept('comment', rules);
    first = non_comments[0];
    if (first.instruction !== 'FROM') {
      if (first.instruction !== 'ARG') {
        utils.log('ERROR', "First instruction must be 'FROM', is: " + first.instruction);
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.no_empty_tag = function(rules) {
    var from, image, j, len, ref, rule, tag;
    from = this.getAll('FROM', rules);
    for (j = 0, len = from.length; j < len; j++) {
      rule = from[j];
      if (rule["arguments"][0].match(/:/)) {
        ref = rule["arguments"][0].split(':'), image = ref[0], tag = ref[1];
        if (!utils.notEmpty(tag)) {
          utils.log('ERROR', "Tag must not be empty for \"" + image + "\" on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.no_empty_digest = function(rules) {
    var digest, from, image, j, len, ref, rule;
    from = this.getAll('FROM', rules);
    for (j = 0, len = from.length; j < len; j++) {
      rule = from[j];
      if (rule["arguments"][0].match(/@/)) {
        ref = rule["arguments"][0].split('@'), image = ref[0], digest = ref[1];
        if (!utils.notEmpty(digest)) {
          utils.log('ERROR', "Digest must not be empty for \"" + image + "\" on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.json_array_format = function(rules) {
    var arg, argument, errmsg, i, j, k, l, len, len1, len2, len3, n, r, ref, ref1, ref2, rule;
    ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        errmsg = "Arguments to " + i + " in exec form must not contain single quotes on line " + r.line;
        ref1 = r["arguments"];
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          argument = ref1[l];
          if (argument.match(/^\[.*\]/)) {
            ref2 = argument.split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, -1);
            for (n = 0, len3 = ref2.length; n < len3; n++) {
              arg = ref2[n];
              if (!arg.trim().match(/^(\[?(\s+)?\".*\"(\s+)?\]?)|(\[\])$/)) {
                utils.log('ERROR', errmsg);
                return 'failed';
              }
            }
          }
        }
      }
    }
    return 'ok';
  };

  exports.json_array_even_quotes = function(rules) {
    var i, j, k, len, len1, quotes, r, ref, rule;
    ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        quotes = r["arguments"].join(' ').split('"');
        if (!(quotes.length % 2)) {
          utils.log('ERROR', "Odd number of double quotes on line " + r.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.json_array_brackets = function(rules) {
    var arg2json, e, i, j, k, len, len1, nArray, r, ref, rule;
    ref = ['CMD', 'ENTRYPOINT', 'RUN', 'VOLUME'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        if (!r["arguments"][0].match(/(^\s*\[)|(\]\s*$)/g)) {
          continue;
        }
        try {
          arg2json = JSON.parse(r["arguments"].join(' '));
          nArray = arg2json.filter(function(z) {
            return utils.isArray(z);
          });
          if (nArray.length > 0) {
            utils.log('ERROR', "Nested array found on line " + r.line);
            return 'failed';
          }
          return 'ok';
        } catch (error) {
          e = error;
          utils.log('ERROR', "Invalid array on line " + r.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.recommended_exec_form = function(rules) {
    var i, j, k, lbracket, len, len1, nr, r, rbracket, ref, rule;
    ref = ['CMD', 'ENTRYPOINT'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      rule = this.getAll(i, rules);
      for (k = 0, len1 = rule.length; k < len1; k++) {
        r = rule[k];
        nr = r["arguments"].join(' ').split(/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, -1);
        lbracket = nr[0].match(/\[/g);
        rbracket = nr[nr.length - 1].match(/\]/g);
        if ((lbracket == null) || (rbracket == null)) {
          utils.log(exports.pedantic_severity, "Recommended exec/array form not used on line " + r.line);
          return exports.pedantic_ret;
        }
      }
    }
    return 'ok';
  };

  exports.add = function(rules) {
    var add, j, len, lines, rule;
    add = this.getAll('ADD', rules);
    if (add.length > 0) {
      lines = [];
      for (j = 0, len = add.length; j < len; j++) {
        rule = add[j];
        if (!rule["arguments"][0].match(/\.(tar|gz|bz2|xz)/)) {
          lines.push(rule.line);
        }
      }
      if (lines.length > 0) {
        utils.log(exports.pedantic_severity, "ADD instruction used instead of COPY on line " + (lines.join(', ')));
        return exports.pedantic_ret;
      }
    }
    return 'ok';
  };

  exports.multiple_entries = function(rules) {
    var e, j, len, ref, rule;
    ref = ['CMD', 'ENTRYPOINT'];
    for (j = 0, len = ref.length; j < len; j++) {
      e = ref[j];
      rule = this.getAll(e, rules);
      if (rule.length > 1) {
        utils.log('ERROR', "Multiple " + e + " instructions found, only line " + rule[rule.length - 1].line + " will take effect");
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.sudo = function(rules) {
    var argument, j, k, len, len1, ref, rule, run;
    run = this.getAll('RUN', rules);
    for (j = 0, len = run.length; j < len; j++) {
      rule = run[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        if (argument.match(/(^|.*;)\s*(\/?.*\/)?sudo(\s|$)/)) {
          utils.log(exports.pedantic_severity, "sudo(8) usage found on line " + rule.line + " which is discouraged");
          return exports.pedantic_ret;
        }
      }
    }
    return 'ok';
  };

  exports.env = function(rules, ignore) {
    var environs, j, len, rule;
    if (ignore == null) {
      ignore = false;
    }
    environs = this.getAll('ENV', rules);
    for (j = 0, len = environs.length; j < len; j++) {
      rule = environs[j];
      if (exports.mergeVariables(exports.env, rule, false) !== 'ok') {
        if (!ignore) {
          utils.log('ERROR', "ENV invalid format " + rule["arguments"] + " on line " + rule.line);
        }
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.arg = function(rules, ignore) {
    var j, k, len, len1, pre, ref, rule;
    if (ignore == null) {
      ignore = false;
    }
    ref = ['HTTP_PROXY', 'http_proxy', 'HTTPS_PROXY', 'http_proxy', 'FTP_PROXY', 'ftp_proxy', 'NO_PROXY', 'no_proxy'];
    for (j = 0, len = ref.length; j < len; j++) {
      pre = ref[j];
      exports.arg[pre] = 'true';
    }
    args = this.getAll('ARG', rules);
    for (k = 0, len1 = args.length; k < len1; k++) {
      rule = args[k];
      if (exports.mergeVariables(exports.arg, rule, true) !== 'ok') {
        if (!ignore) {
          utils.log('ERROR', "ARG invalid format " + rule["arguments"] + " on line " + rule.line);
        }
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.absolute_workdir = function(rules) {
    var absolute, j, len, m, match, rule, vars, workdir;
    vars = this.getAllVariables(rules);
    workdir = this.getAll('WORKDIR', rules);
    for (j = 0, len = workdir.length; j < len; j++) {
      rule = workdir[j];
      while (match = exports.varPattern.exec(rule["arguments"][0])) {
        m = match[1] || match[2];
        if (exports.arg[m]) {
          if (!exports.env[m]) {
            utils.log(exports.pedantic_severity, "WORKDIR path " + rule["arguments"] + " contains an ARG variable. WORKDIR should resolve to an absolute path at build time");
            return exports.pedantic_ret;
          }
        }
      }
      rule["arguments"][0] = exports.variablesReplace(vars, rule["arguments"][0]);
      if (typeof path.isAbsolute !== "undefined") {
        absolute = path.isAbsolute(rule["arguments"][0]);
      } else {
        absolute = rule["arguments"][0].charAt(0) === '/';
      }
      if (!absolute) {
        utils.log('ERROR', "WORKDIR path " + rule["arguments"] + " must be absolute on line " + rule.line);
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.onbuild_copyadd = function(rules) {
    var argument, j, k, len, len1, onbuild, ref, rule;
    onbuild = this.getAll('ONBUILD', rules);
    for (j = 0, len = onbuild.length; j < len; j++) {
      rule = onbuild[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        if (argument.match(/ADD|COPY/)) {
          utils.log(exports.pedantic_severity, "It is advised not to use ADD or COPY for ONBUILD on line " + rule.line);
          return exports.pedantic_ret;
        }
      }
    }
    return 'ok';
  };

  exports.onbuild_disallowed = function(rules) {
    var argument, chained_instruction, j, k, len, len1, onbuild, ref, rule;
    onbuild = this.getAll('ONBUILD', rules);
    for (j = 0, len = onbuild.length; j < len; j++) {
      rule = onbuild[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        chained_instruction = argument.split(' ')[0];
        if (chained_instruction.match(/ONBUILD|FROM|MAINTAINER/)) {
          utils.log('ERROR', "ONBUILD may not be chained with " + chained_instruction + " on line " + rule.line);
          return 'failed';
        }
      }
    }
    return 'ok';
  };

  exports.label_no_empty_value = function(rules) {
    var argument, j, k, l, label, len, len1, len2, pair, ref, ref1, rule;
    label = this.getAll('LABEL', rules);
    for (j = 0, len = label.length; j < len; j++) {
      rule = label[j];
      ref = rule["arguments"];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        argument = ref[k];
        ref1 = argument.split(' ');
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          pair = ref1[l];
          if (pair.slice(-1) === '=') {
            utils.log('ERROR', "LABEL requires value for line " + rule.line);
            return 'failed';
          }
        }
      }
    }
    return 'ok';
  };

  exports.variable_use = function(rules) {
    var argument, i, instruction, j, k, l, len, len1, len2, ref, ref1, rule, vars;
    vars = this.getAllVariables(rules);
    ref = ['ADD', 'COPY', 'ENV', 'EXPOSE', 'FROM', 'LABEL', 'ONBUILD', 'RUN', 'STOPSIGNAL', 'USER', 'VOLUME', 'WORKDIR'];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      instruction = this.getAll(i, rules);
      for (k = 0, len1 = instruction.length; k < len1; k++) {
        rule = instruction[k];
        ref1 = rule["arguments"];
        for (l = 0, len2 = ref1.length; l < len2; l++) {
          argument = ref1[l];
          if (exports.variablesDefined(vars, argument) !== 'ok') {
            utils.log('ERROR', rule.instruction + " contains undefined ARG or ENV variable on line " + rule.line);
            return 'failed';
          }
        }
      }
    }
    return 'ok';
  };

  exports.no_trailing_spaces = function(rules) {
    var j, len, rule;
    for (j = 0, len = rules.length; j < len; j++) {
      rule = rules[j];
      if (rule.raw.endsWith(' ')) {
        utils.log('ERROR', 'Lines cannot have trailing spaces');
        return 'failed';
      }
    }
    return 'ok';
  };

  exports.unknown_instruction = function(rules) {
    var allowed_instructions, j, len, non_comments, ref, rule;
    allowed_instructions = ['ADD', 'ARG', 'CMD', 'COPY', 'ENTRYPOINT', 'ENV', 'EXPOSE', 'FROM', 'HEALTHCHECK', 'LABEL', 'MAINTAINER', 'ONBUILD', 'RUN', 'SHELL', 'STOPSIGNAL', 'USER', 'VAR', 'VOLUME', 'WORKDIR'];
    non_comments = this.getAllExcept('comment', rules);
    for (j = 0, len = non_comments.length; j < len; j++) {
      rule = non_comments[j];
      if (ref = rule.instruction, indexOf.call(allowed_instructions, ref) < 0) {
        if (utils.notEmpty(rule.instruction)) {
          utils.log('ERROR', rule.instruction + " is invalid on line " + rule.line);
        } else {
          utils.log('ERROR', "Empty / bogus instruction is invalid on line " + rule.line);
        }
        return 'failed';
      }
    }
    return 'ok';
  };

}).call(this);
