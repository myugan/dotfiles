'use strict';
'use babel';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unlinkFile = exports.writeFile = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.getWordRegexp = getWordRegexp;
exports.getTempDirectory = getTempDirectory;
exports.fileExists = fileExists;
exports.validateExec = validateExec;
exports.validateEditor = validateEditor;
exports.validateFind = validateFind;
exports.wrapExec = wrapExec;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _tmp = require('tmp');

var _tmp2 = _interopRequireDefault(_tmp);

var _sbPromisify = require('sb-promisify');

var _sbPromisify2 = _interopRequireDefault(_sbPromisify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var writeFile = exports.writeFile = (0, _sbPromisify2.default)(_fs2.default.writeFile);
var unlinkFile = exports.unlinkFile = (0, _sbPromisify2.default)(_fs2.default.unlink);

function escapeRegexp(string) {
  // Shamelessly stolen from https://github.com/atom/underscore-plus/blob/130913c179fe1d718a14034f4818adaf8da4db12/src/underscore-plus.coffee#L138
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}

function getWordRegexp(textEditor, bufferPosition) {
  var scopeDescriptor = textEditor.scopeDescriptorForBufferPosition(bufferPosition);
  var nonWordCharacters = escapeRegexp(atom.config.get('editor.nonWordCharacters', {
    scope: scopeDescriptor
  }));
  return new RegExp('^[\t ]*$|[^\\s' + nonWordCharacters + ']+');
}

function getTempDirectory(prefix) {
  return new Promise(function (resolve, reject) {
    _tmp2.default.dir({ prefix: prefix }, function (error, directory, cleanup) {
      if (error) {
        reject(error);
      } else resolve({ path: directory, cleanup: cleanup });
    });
  });
}

function fileExists(filePath) {
  return new Promise(function (resolve) {
    _fs2.default.access(filePath, _fs2.default.R_OK, function (error) {
      resolve(error === null);
    });
  });
}

function validateExec(command, args, options) {
  if (typeof command !== 'string') {
    throw new Error('Invalid or no `command` provided');
  } else if (!(args instanceof Array)) {
    throw new Error('Invalid or no `args` provided');
  } else if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
    throw new Error('Invalid or no `options` provided');
  }
}

function validateEditor(editor) {
  var isEditor = void 0;
  if (typeof atom.workspace.isTextEditor === 'function') {
    // Added in Atom v1.4.0
    isEditor = atom.workspace.isTextEditor(editor);
  } else {
    isEditor = typeof editor.getText === 'function';
  }
  if (!isEditor) {
    throw new Error('Invalid TextEditor provided');
  }
}

function validateFind(directory, name) {
  if (typeof directory !== 'string') {
    throw new Error('Invalid or no `directory` provided');
  } else if (typeof name !== 'string' && !(name instanceof Array)) {
    throw new Error('Invalid or no `name` provided');
  }
}

var processMap = new Map();

function wrapExec(callback) {
  return function (filePath, parameters) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var killed = false;
    var spawned = callback(filePath, parameters, Object.assign({ timeout: 10000 }, options));
    var mirror = spawned;

    if (options.uniqueKey) {
      if (typeof options.uniqueKey !== 'string') throw new Error('options.uniqueKey must be a string');

      var oldValue = processMap.get(options.uniqueKey);
      if (oldValue) {
        oldValue();
      }
      processMap.set(options.uniqueKey, function () {
        killed = true;
        spawned.kill();
      });
      mirror = mirror.then(function (value) {
        if (killed) return null;
        return value;
      }, function (error) {
        if (killed) return null;
        throw error;
      });
    }

    return mirror.catch(function (error) {
      if (error.code === 'ENOENT') {
        var newError = new Error('Failed to spawn command `' + error.path + '`. Make sure `' + error.path + '` is installed and on your PATH');
        // $FlowIgnore: Custom property
        newError.code = 'ENOENT';
        throw newError;
      }
      throw error;
    });
  };
}