'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSpawnOptions = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var getSpawnOptions = exports.getSpawnOptions = function () {
  var _ref = _asyncToGenerator(function* (options) {
    var spawnOptions = Object.assign({}, options, {
      env: mergeEnv((yield (0, _consistentEnv.async)()), options.env)
    });
    var npmPath = void 0;
    var local = options.local;
    if (local) {
      npmPath = yield (0, _sbNpmPath.getPathAsync)(local.directory);
    }
    if (local && npmPath) {
      for (var key in spawnOptions.env) {
        if ({}.hasOwnProperty.call(spawnOptions.env, key) && key === 'PATH') {
          var value = spawnOptions.env[key];
          spawnOptions.env[key] = local.prepend ? npmPath + PATH_SEPARATOR + value : value + PATH_SEPARATOR + npmPath;
          break;
        }
      }
    }
    delete spawnOptions.timeout;
    if (spawnOptions.env.OS) {
      spawnOptions.env.OS = undefined;
    }
    if (process.versions.electron) {
      spawnOptions.env.ELECTRON_RUN_AS_NODE = '1';
      spawnOptions.env.ATOM_SHELL_INTERNAL_RUN_AS_NODE = '1';
      spawnOptions.env.ELECTRON_NO_ATTACH_CONSOLE = '1';
    }
    return spawnOptions;
  });

  return function getSpawnOptions(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.validate = validate;
exports.mergePath = mergePath;
exports.mergeEnv = mergeEnv;
exports.escape = escape;
exports.shouldNormalizeForWindows = shouldNormalizeForWindows;
exports.getENOENTError = getENOENTError;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _lodash = require('lodash.uniq');

var _lodash2 = _interopRequireDefault(_lodash);

var _consistentEnv = require('consistent-env');

var _sbNpmPath = require('sb-npm-path');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var PATH_SEPARATOR = process.platform === 'win32' ? ';' : ':';

function validate(filePath, parameters, givenOptionsAccepted) {
  // NOTE: We need to specify type of this to object to supress some warnings that rise from the merge (Flow, duh)
  var defaultOptions = {};
  var options = Object.assign(defaultOptions, givenOptionsAccepted);

  (0, _assert2.default)(typeof filePath === 'string' && filePath, 'filePath must be a string');
  (0, _assert2.default)(Array.isArray(parameters), 'parameters must be an array');

  (0, _assert2.default)((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options, 'options must be an object');
  if (options.stream) {
    var stream = options.stream;
    (0, _assert2.default)(stream === 'both' || stream === 'stdout' || stream === 'stderr', 'options.stream should be stdout|stderr|both');
  } else options.stream = 'stdout';
  if (options.timeout) {
    (0, _assert2.default)(typeof options.timeout === 'number', 'options.timeout must be a number');
  } else options.timeout = Infinity;
  if (options.env) {
    (0, _assert2.default)(_typeof(options.env) === 'object', 'options.env must be an object');
  } else options.env = {};
  if (options.stdin) {
    (0, _assert2.default)(typeof options.stdin === 'string' || Buffer.isBuffer(options.stdin), 'options.stdin must be a string or a Buffer');
  } else options.stdin = null;
  if (typeof options.throwOnStderr !== 'undefined') {
    (0, _assert2.default)(typeof options.throwOnStderr === 'boolean', 'options.throwOnStderr must be a boolean');
  } else options.throwOnStderr = true;
  if (typeof options.local !== 'undefined') {
    (0, _assert2.default)(_typeof(options.local) === 'object', 'options.local must be an object');
    (0, _assert2.default)(typeof options.local.directory === 'string', 'options.local.directory must be a string');
    if (typeof options.local.prepend !== 'undefined') {
      (0, _assert2.default)(typeof options.local.prepend === 'boolean', 'options.local.prepend must be a boolean');
    } else options.local.prepend = false;
  }
  if (typeof options.allowEmptyStderr !== 'undefined') {
    (0, _assert2.default)(typeof options.allowEmptyStderr === 'boolean', 'options.throwWhenEmptyStderr must be a boolean');
  } else options.allowEmptyStderr = false;
  if (typeof options.ignoreExitCode !== 'undefined') {
    (0, _assert2.default)(typeof options.ignoreExitCode === 'boolean', 'options.ignoreExitCode must be a boolean');
  } else options.ignoreExitCode = false;

  return options;
}

function mergePath(a, b) {
  return (0, _lodash2.default)(a.split(';').concat(b.split(';')).map(function (i) {
    return i.trim();
  }).filter(function (i) {
    return i;
  })).join(';');
}

function mergeEnv(envA, envB) {
  if (process.platform !== 'win32') {
    return Object.assign(envA, envB);
  }

  // NOTE: Merge PATH and Path on windows
  var mergedEnv = { PATH: '' };
  for (var key in envA) {
    if (key.toUpperCase() !== 'PATH') {
      mergedEnv[key] = envA[key];
      continue;
    }
    mergedEnv.PATH = mergePath(mergedEnv.PATH, envA[key]);
  }
  for (var _key in envB) {
    if (_key.toUpperCase() !== 'PATH') {
      mergedEnv[_key] = envB[_key];
      continue;
    }
    mergedEnv.PATH = mergePath(mergedEnv.PATH, envB[_key]);
  }
  return mergedEnv;
}

function escape(item) {
  return '"' + String(item).replace(/"/g, '\\"') + '"';
}

function shouldNormalizeForWindows(filePath, options) {
  var baseFilePath = _path2.default.basename(filePath);
  return process.platform === 'win32' && !options.shell && baseFilePath !== 'cmd.exe' && baseFilePath !== 'cmd';
}

function getENOENTError(filePath, parameters) {
  var error = new Error('spawn ' + filePath + ' ENOENT');
  error.code = 'ENOENT';
  error.errno = 'ENOENT';
  error.syscall = 'spawn ' + filePath;
  error.path = filePath;
  error.spawnargs = parameters;
  return error;
}